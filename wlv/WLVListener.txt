// WLV by Sila Dione / Tursi Jackson - 104 - 6/30/2021
// This integrates a Genesis (1/2/3) - compatible base AO with
// some RLV gestures for turning
//
// We work around the AO race by not doing a manual AO, we just use llSetAnimationOverride!
// We don't do STAND because the way that CLEAR works makes it break pretty badly. Everything else
// should be okay! :)
//
// ** debug stuff **
// it's the define, not the value that matters
//#define DEBUG 1

// debug wrapper
#ifdef DEBUG
debug(string str) {
    llOwnerSay("DEBUG[" + (string)llGetTime() + "]: " + str);
}
#else
#define debug(dummy)
#endif

// ** Gesture Stuff **
// channel must match the channel used in the gestures!
// RLV channels must be positive!
#define GESTURECHAN 56929
integer gestureListen = 0;

#define FULLPI 3.14159265
#define HALFPI 1.57079633

// ** AO stuff **
#define ROTATE_ON <0.00000, 0.00000, -1.00000, 0.00000>
#define ROTATE_OFF <-0.00000, -0.00000, 0.70711, 0.70711>
#define ROTATE_PAUSE <0.00000, 0.00000, -0.70711, 0.70711>
#define ROTATE_RESET <-0.00000, -0.00000, 0.00000, 1.00000>

// track our state
integer gotSettings = 0;
integer gotRLV = 0;

// these hold the AO animations to actually use
string WALKANIM;
string RUNANIM;
string JUMPANIM;
string STANDUPANIM;

// ** Settings stuff
// reading the settings notecard
#define settingsCard "settings"
key cardHandle;                 // reading handle
integer cardLine;               // reading line
key cardUUID;                   // lets us detect that it was the notecard which changed

// remember values
key owner;

// We don't need on and off modes anymore, as the AO is internal now, no animations are triggered
seton() {
    llSetLinkPrimitiveParamsFast( LINK_THIS, [PRIM_ROT_LOCAL, ROTATE_ON] );
}

// not used anymore, unless we fail to start
setoff() {
    llSetLinkPrimitiveParamsFast( LINK_THIS, [PRIM_ROT_LOCAL, ROTATE_OFF] );
}

// not used anymore
setpaused(float pause) {
    llSetLinkPrimitiveParamsFast( LINK_THIS, [PRIM_ROT_LOCAL, ROTATE_PAUSE] );    
}

// helper function to check if animation in inventory, save a little memory
integer checkInventory(string str, integer type) {
    if (type != llGetInventoryType(str)) {
        llOwnerSay("Failed inventory check, wrong type or can't find: '" + str + "'");
        return 0;
    }
    return 1;
}

default
{
    state_entry()
    {
        // visual feedback
        llSetLinkPrimitiveParamsFast( LINK_THIS, [PRIM_ROT_LOCAL, ROTATE_RESET] );    
        
        // remember who owns us
        owner = llGetOwner();
        if (llGetAttached() == 0) {
            llOwnerSay("HUD is not attached - disabling.");
            state dead;
        }
        
        // ask if RLV is there
        llSetTimerEvent(30.0);
        gestureListen = llListen(GESTURECHAN, "", NULL_KEY, "");
        llOwnerSay("@version="+(string)GESTURECHAN);

        // start the notecard while we wait
        llOwnerSay("Reading notecard...");
        
        cardUUID = llGetInventoryKey(settingsCard);
        cardLine = 0;
        cardHandle = llGetNotecardLine(settingsCard, cardLine);
    }
    
    on_rez(integer n) {
        llResetScript();
    }
    
    changed(integer change) {
        if (change & CHANGED_INVENTORY) {
            if (cardUUID != llGetInventoryKey(settingsCard)) {
                llResetScript();
            }
        }
    }
    
    attach(key id) {
        if (NULL_KEY != id) {
            llResetScript();
        }
    }

    listen(integer channel, string who, key id, string msg) {
        if (channel == GESTURECHAN) {
            if (llGetSubString(msg, 0, 9) == "Restrained") {
                // least common case - version return
                llOwnerSay("RLV detected.");
                llSetTimerEvent(0.0);
                gotRLV = 1;
                if (gotSettings) {
                    state main;
                }
                return;
            }
        }
    }
    
    timer() {
        llSetTimerEvent(0.0);
        llOwnerSay("Did not receive reply from RLV system, is it on?");
        state dead;
    }

    // input from the settings notecard
    dataserver(key id, string data) {
        if (id == cardHandle) {
            if (data == EOF) {
                llOwnerSay("Notecard read complete, " + (string)llGetFreeMemory() + " bytes free.");
                gotSettings = 1;
                if (gotRLV) {
                    state main;
                }
                return;
            }
            
            // increment early - it's better for debug
            ++cardLine;
            
            data = llStringTrim(data, STRING_TRIM);
            if ((llStringLength(data) > 0) && (llGetSubString(data, 0, 0) != "#")) {
                // now we are looking for token=value strings
                list lst = llParseString2List(data, ["="], []);
                if (llGetListLength(lst) == 2) {
                    // token=value
                    string token = llToUpper(llStringTrim(llList2String(lst, 0), STRING_TRIM));
                    string value = llStringTrim(llList2String(lst, 1), STRING_TRIM);
                    
                    if (token == "WALKANIM") {
                        WALKANIM = value;
                        if (!checkInventory(WALKANIM, INVENTORY_ANIMATION)) {
                            state dead; 
                        }
                    } else if (token == "STANDANIM") {
                        // ignore this
                        llOwnerSay("STANDANIM is obsolete, you may remove it.");
                    } else if (token == "RUNANIM") {
                        RUNANIM = value;
                        if (!checkInventory(RUNANIM, INVENTORY_ANIMATION)) {
                            state dead; 
                        }
                    } else if (token == "JUMPANIM") {
                        JUMPANIM = value;

                        if (!checkInventory(JUMPANIM, INVENTORY_ANIMATION)) {
                            state dead; 
                        }
                    } else if (token == "STANDUPANIM") {
                        STANDUPANIM = value;
                        if (!checkInventory(STANDUPANIM, INVENTORY_ANIMATION)) {
                            state dead; 
                        }
                    } else {
                        llOwnerSay("Unknown token in line " + (string)cardLine + ": " + data);
                        state dead;
                    }
                }
            }

            // and request the next line
            cardHandle = llGetNotecardLine(settingsCard, cardLine);
        }
    }
}

state dead
{
    on_rez(integer x) {
        llResetScript();
    }
    
    attach(key id) {
        if (id != NULL_KEY) { 
            llResetScript();
        }
    }
    
    changed(integer change) {
        if (change & CHANGED_INVENTORY) {
            if (cardUUID != llGetInventoryKey(settingsCard)) {
                llResetScript();
            }
        }
    }
    
    state_entry()
    {
        setoff();
        llOwnerSay("Startup failed - correct and then reset all scripts");
        llSetTimerEvent(0.0);
    }
}

state main
{
    on_rez(integer x) {
        llResetScript();
    }
    
    attach(key id) {
        if (id != NULL_KEY) { 
            llResetScript();
        }
    }
    
    changed(integer change) {
        if (change & CHANGED_INVENTORY) {
            if (cardUUID != llGetInventoryKey(settingsCard)) {
                llResetScript();
            }
        }
    }

    state_entry()
    {
        integer aoOn = -1;
        string aos;
        if (WALKANIM != "") { aoOn = 1; aos += "walk "; }
        if (RUNANIM != "") { aoOn = 1; aos += "run "; }
        if (JUMPANIM != "") { aoOn = 1;  aos += "jump "; }
        if (STANDUPANIM != "") { aoOn = 1; aos += "stand up "; }
        if (aoOn > 0) { 
            llOwnerSay("Replacement animations defined: " + aos);
            // get animation permissions
            llRequestPermissions(owner, PERMISSION_OVERRIDE_ANIMATIONS);
        } else {
            llOwnerSay("No Animations defined");
        }
        gestureListen = llListen(GESTURECHAN, "", NULL_KEY, "");
        llSetTimerEvent(0.0);
        llOwnerSay("WLV Ready to go!");
        seton();
    }

    // comes here after state_entry's request for animation permissions, finish up if we get them
    run_time_permissions(integer p) {
        if (p & PERMISSION_OVERRIDE_ANIMATIONS) {
            llResetAnimationOverride("ALL");
            if (WALKANIM != "") llSetAnimationOverride("Walking", WALKANIM);
            if (RUNANIM != "") llSetAnimationOverride("Running", RUNANIM);
            if (JUMPANIM != "") llSetAnimationOverride("Jumping", JUMPANIM);
            if (STANDUPANIM != "") llSetAnimationOverride("Standing Up", STANDUPANIM);
        } else {
            llOwnerSay("AO functions will not activate due to no permission.");
        }
    }
    
    listen(integer chan, string name, key id, string msg) {
        if (chan == GESTURECHAN) {
            if (msg == "L90") {
                // left turn
                vector fwd = <1,0,0>*llGetRootRotation();
                float angle = llAtan2(fwd.x, fwd.y) - HALFPI;
                llOwnerSay("@setrot:" + (string)angle + "=force");
            } else if (msg == "R90") {
                // right turn
                vector fwd = <1,0,0>*llGetRootRotation();
                float angle = llAtan2(fwd.x, fwd.y) + HALFPI;
                llOwnerSay("@setrot:" + (string)angle + "=force");
            } else if (msg == "L180") {
                // left 180 - to force left, try to avoid sign change
                // just observation, but seems to work for now
                vector fwd = <1,0,0>*llGetRootRotation();
                // half to do it as two steps to force left turn
                float angle = llAtan2(fwd.x, fwd.y) - HALFPI;
                llOwnerSay("@setrot:" + (string)angle + "=force");
                llSleep(0.1);
                angle -= HALFPI;
                llOwnerSay("@setrot:" + (string)angle + "=force");
            }
        }
    }
}
